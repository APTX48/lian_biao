＃树算法
二叉树
1.	已知一颗二叉树的先序和中序序列（后序和中序），恢复二叉树。
2.	判断一颗二叉树是否是完全二叉树，平衡二叉树，二叉排序树。
3.	求两个结点的最近公共祖先结点。
4.	根到某结点的路径（后序非递归遍历）/打印值为x结点的所有祖先，假设值为x的结点不多与一个。这两个一样的，表述不一样而已
5.	自上而下，自左向右 /自下而上，自左向右 /自下而上，自右向左的遍历。
6.	求一颗二叉树的宽度，高度，直径
7.	求二叉树中独生叶结点的个数（每一层独生叶结点的个数），叶子结点总数，双分支结点个数
8.	先根次序遍历二叉树，输出所有的结点的关键字及层次。/先序遍历序列第k个结点值。
9.	n个节点的完全二叉树存放在数组A[n]中，建立一棵用二叉链表表示的二叉树根用tree指向。并遍历这棵二叉树
10. 根据给定序列创建二叉树。
11.	判断两棵树是否相同/相似。
12.	判断一棵二叉树是否对称。/翻转一棵二叉树，每个结点的左右结点交换。
13.	删除每个元素值为x的结点，删去以它为根的子树，并释放相应的空间。
14.	打印二叉树中左子树非空右子树为空的所有结点。
15.	找出二叉树先根序列的最后一个结点，不使用栈，不使用递归。
16.	输出该二叉树中第一条最长的路径长度，并输出此路径上各结点的值。
17.	一棵二叉树以链接形式存储，结点结构为(Left, Data, Right), 设计一算法，求二叉树中从根结点到叶结点的一条路径长度等于树的高度的路径，若有这样的路径存在多条，则输出路径终点（叶结点）在“最左”的一条。
18.	设计一个算法求结点x在二叉树中的双亲。
19.	一棵二叉树以链接形式存储，结点结构为（Left, Data, Right）,求其指定的某一层k(k>0)上的叶子结点个数。
